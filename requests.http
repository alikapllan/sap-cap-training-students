### Get all Students
GET http://localhost:4004/odata/v4/catalog/Student
Accept: application/json

###

### Get a Student by key
GET http://localhost:4004/odata/v4/catalog/Student(email='alice.wonderland@example.com')
Accept: application/json


### Update a Student (via UpdateStudent)
PATCH http://localhost:4004/odata/v4/catalog/UpdateStudent(email='alice.wonderland@example.com')
Content-Type: application/json

{
  "first_name": "UpdatedName"
}

###

### Insert a single Student
POST http://localhost:4004/odata/v4/catalog/InsertStudent
Content-Type: application/json

{
  "email": "new.student@example.com",
  "first_name": "New",
  "last_name": "Student",
  "date_sign_up": "2025-08-26"
}

### Insert multiple Students
POST http://localhost:4004/odata/v4/catalog/insertManyStudents
Content-Type: application/json

{
  "students": [
    {
      "email": "multi.one@example.com",
      "first_name": "Multi",
      "last_name": "One",
      "date_sign_up": "2025-08-26"
    },
    {
      "email": "multi.two@example.com",
      "first_name": "Multi",
      "last_name": "Two",
      "date_sign_up": "2025-08-26"
    }
  ]
}

###

### DELETE a Student
DELETE http://localhost:4004/odata/v4/catalog/DeleteStudent(email='new.student@example.com')

### Get CustomStudent
GET http://localhost:4004/odata/v4/catalog/CustomGetStudent
Accept: application/json

### Insert a single Student with an illegal email - to trigger before event in the extension mynewsrv.js
POST http://localhost:4004/odata/v4/catalog/InsertStudent
Content-Type: application/json

{
  "email": "new.student@gmail.com",
  "first_name": "New",
  "last_name": "Student",
  "date_sign_up": "2025-08-26"
}


# ==============================================================
#    Optimistic locking:
#    - Create once on the entity set
#    - Read twice (capture ETag1, ETag2)
#    - Update with ETag1 (OK)
#    - Update with ETag2 (FAIL 412)

# how basically works in a scenario
# 1 ETags change on WRITE, not on READ.
# 2 If A and B both read the same record at time T0, they both get the same ETag (say E3).
# 3 writes first with If-Match: E3 → success, server updates the row and bumps ETag to E4.
# 4 then tries to write with If-Match: E3 (now stale) → server returns 412 Precondition Failed.
# 5 If B re-reads (gets E4) and retries with If-Match: E4, it will succeed.
# ================================================================ 

@base = http://localhost:4004/odata/v4/catalog-service-lms
@set  = GetStudent

### 1) Create Student (returns ID of the draft row)
# @name createStudent
POST {{base}}/{{set}}
Content-Type: application/json
Accept: application/json

{
  "email": "optimistic.lock@test.local",
  "first_name": "Initial",
  "last_name": "Version",
  "date_sign_up": "2025-09-05"
}
###
@studentID = {{createStudent.response.body.$.ID}}

### 2) Read Student -> capture ETag1
# @name read1
GET {{base}}/{{set}}(ID={{studentID}},IsActiveEntity=false)
Accept: application/json
###
@ETag1 = {{read1.response.headers.ETag}}

### 3) Read Student again -> capture ETag2 (this will become stale)
# @name read2
GET {{base}}/{{set}}(ID={{studentID}},IsActiveEntity=false)
Accept: application/json
###
@ETag2 = {{read2.response.headers.ETag}}

### 4) Update with ETag1 -> should SUCCEED (new ETag generated)
# @name update_ok
PUT {{base}}/{{set}}(ID={{studentID}},IsActiveEntity=false)
If-Match: {{ETag1}}
Content-Type: application/json
Accept: application/json

{
  "first_name": "Updated Name"
}
###

### 5) Update again with *stale* ETag2 -> should FAIL (412)
# @name update_fail_412
PUT {{base}}/{{set}}(ID={{studentID}},IsActiveEntity=false)
If-Match: {{ETag2}}
Content-Type: application/json
Accept: application/json

{
  "first_name": "Update Name 2"
}